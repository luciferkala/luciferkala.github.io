---
layout: post
title: "13. Node.js Design Pattern - Stream - Start Stream"
date: 2020-01-26
excerpt: "Node.js Design Pattern 책 5강 정리 - 2"
tags: [Development, Node.js, Stream, JavaScript, ECMA2015]
comments: true
---

## 스트림 시작하기

Node.js의 핵심 모듈을 비롯한 모든 곳에서는 스트림을 사용한다.
이제 스트림을 더 자세히 알아보자

### 스트림의 구조

Node.js에서 모든 스트림은 스트림의 코어 모듈에서 사용할 수 있는 네 가지 추상 클래스 중 하나의 구현체이다.

-   stream.Readable
-   stream.Writable
-   stream.Duplex
-   stream.Transform

각 스트림 클래스는 EventEmitter의 인스턴스이기도 하다. 실제로 스트림은 Readable 스트림에서 읽기가 끝났을 때 발생하는 end, 무엇인가 잘못되었을 때 발생하는 error와 같은 여러 가지 유형의 이벤트를 제공한다.

> 간략하게 하기 위해 예제에서는 적절한 오류관리를 생략하는 경우가 많다.
> 그러나 상용 프로그램에서는 항상 모든 스트림에 대한 오류 이벤트 수신기를 등록하는 것이 좋다.

**스트림이 매우 유연한 이유 중 하나는 바이너리 데이터를 처리할 뿐만 아니라 거의 모든 JavaScript의 값을 처리할 수 있다는 것이다.**
실제로 두 가지 동작 모드를 지원할 수 있다.

-   바이너리 모드 : 이 모드는 데이터가 버퍼 또는 문자열과 같은 덩어리(chunk) 형태로 스트리밍되는 모드이다.
-   객체 모드 : 이 모드는 스트리밍 데이터가 일련의 별도 객체들로 취급되는 것이다(거의 모든 JavaScript 값을 사용할 수 있다).

이 두가지 동작 모드를 사용하면 I/O 뿐만 아니라 처리 단위를 기능 단위로 우아하게 구성할 수 있다.

---

### Readable 스트림

Readable 스트림은 데이터 소스를 나타낸다. Node.js에서는 스트림 모듈에서 사용할 수 있는 Readableabstract 클래스를 사용하여 구현된다.

#### 스트림에서 읽기

Readable 스트림에서 데이터를 수신하는 방법에는 non-flowing, flowing 이렇게 두 가지가 있다. 이 모드들을 좀 더 자세히 살펴보겠다.

##### **_non_flowing 모드_**

Readable 스트림에서 읽기의 기본 패턴은 새로운 데이터를 읽을 준비가 되었다는 신호인 readable 이벤트에 대하여 listener를 등록하는 것이다.
그런 다음 루프에서 내부의 버퍼가 비워질 때까지 모든 데이터를 읽는다.
이것은 내부 버퍼에서 동기식으로 데이터 덩어리(chunk)를 읽고 Buffer 또는 String 객체를 반환하는 read() 메소드를 사용하여 수행할 수 있다.
read() 메소드는 다음과 같은 특징을 가진다.

```
readable.read([size])
```

이 접근 방식을 사용하여 필요할 때 즉시 스트림으로부터 명시적으로 데이터를 가져올 수 있다.
readStdin.js라는 새로운 모듈을 만들어 보면서 이것이 어떻게 동작하는지 알아보자.
이 모듈은 표준 입력으로부터 읽고 표준 출력으로 그대로 되돌려주도록 간단하게 구현된 프로그램이다.

```javascript
process.stdin.on('readable', () => {
    let chunk;
    console.log('New data available');
    while((chunk = process.stdin.read()) !== null) {
        console.log(`Chunk read: (${chunk.length}) "${chunk.toString()})`
    }
})
.on('end', () => process.stdout.write('End of stream'))
```

read() 메소드는 Readable 스트림의 내부 버퍼에서 데이터를 읽어들이는 동기 작업이다.
스트림이 바이너리 모드로 동작하고 있는 경우, 기본적으로 반환되는 데이터는 Buffer 객체이다.

> 바이너리 모드로 동작하는 Readable 스트림에서 스트림의 setEncoding(encoding)을 호출하여 buffer를 대신해서 string을 읽을 수 있으며, 유효한 인코딩 형식(예를 들어, utf8)을 제공할 수 있다.

데이터는 readable 리스너에서 독점적으로 읽을 수 있다.
리스너는 새로운 데이터가 읽기 가능하게 되는 즉시 호출된다.
read() 메소드는 내부 버퍼에 더 이상 사용할 수 있는 데이터가 없을 때 null을 반환한다.
이 경우 다시 읽을 수 있다는 이벤트 또는 스트림의 끝을 알리는 end 이벤트가 발생할 때까지 기다려야 한다.
스트림이 바이너리 모드에서 동작할 때는 size 값을 read() 메소드에 전달하여 특정 양의 데이터를 읽어들일 것이라고 지정할 수 있다.
특히 특정 형식의 네트워크 프로토콜이나 특정 데이터 형식으로 분석하는 구현에 유용하다.

이제 readStdin 모듈을 실행하여 시험할 준비가 되었다.
콘솔에 몇 가지 문자를 입력하고 Enter 키를 눌러서 다시 표준 출력으로 에코된 데이터를 확인한다.
스트림을 종료하고 적절한 종료 이벤트를 만들기 위해서는 EOF(End-Of-File) 문자를 전달해야 한다.(Windows에서는 Ctrl + Z, Linux에서는 Ctrl + D)

프로그램을 다른 프로세스와 연결할 수도 있다. 파이프 연산자('|')를 사용하면 프로그램의 표준 출력을 다른 프로그램의 표준 입력으로 리다이렉션 할 수 있다.
예를 들어 다음과 같은 명령을 실행할 수 있다.

```
cat <path to a file> | node readStdin
```

이것은 스트리밍 패러다임이 작성된 언어와는 관계없이 프로그램 간의 통신을 할 수 있게 해주는 보편적인 인터페이스임을 보여주는 좋은 예이다.

##### **_Flowing 모드_**

스트림으로부터 데이터를 읽는 또 다른 방법은 data 이벤트에 리스너를 등록하는 것이다.
이것은 스트림을 **Flowing 모드**로 전환한다. 여기서 데이터는 read()를 사용하여 꺼내지 않고 데이터가 도착하자마자 해당 리스너에 전달된다. 예를 들어, 앞서 만든 readStdin 프로그램은 Flowing 모드에서는 다음과 같이 된다.

```javascript
process.stdin
    .on("data", chunk => {
        console.log("New data available");
        console.log(`Chunk read: (${chunk.length}) "${chunk.toString()}"`);
    })
    .on("end", () => process.stdout.write("End of stream"));
```

Flowing 모드는 **이전 버전의 스트림 인터페이스(Stream1이라고도 함)의 상속이며, 데이터 흐름 제어를 위한 유연성이 떨어진다.** Stream2 인터페이스의 도입으로 Flowing 모드는 기본 작동 모드가 아니다.
이를 사용하려면 data 이벤트에 리스너를 등록하거나 resume() 메소드를 명시적으로 호출해야 한다.
스트림에서 data 이벤트 발생을 일시적으로 중지시키기 위해서는 pause() 메소드를 호출하는데, 이 경우 들어오는 데이터는 내부 버퍼에 캐시된다.

> pause()를 호출한다 해도 스트림이 다시 non-flowing 모드로 전환되지 않는다.

#### Readable 스트림 구현하기

스트림에서 데이터를 읽는 방법을 익혔으므로, 다음 단계로 새로운 Readable 스트림을 구현하는 방법을 알아보자.
이렇게 하면 stream.Readable의 prototype을 상속한 새로운 클래스를 만들어야 한다.
실제 stream은 아래와 같은 특성을 가지는 \_read() 메소드의 구현체를 제공해야 한다.

```
readable._read(size)
```

Readable 클래스는 내부적으로 push() 메소드를 사용하여 내부 버퍼를 채우는 \_read() 메소드를 호출한다.

```
readable.push(chunk)
```

> read()는 스트림의 소비자에 의해 호출되는 메소드이고, \_read() 스트림의 서브 클래스에 의해 구현되며 직접 호출해서는 안된다는 점을 주의한다. 밑줄로 시작하는 함수는 일반적으로 해당 함수가 public이 아니므로 직접 호출해서는 안된다는 의미를 가진다.

새로운 Readable 스트림을 어떻게 구현하는지 보여주기 위해 임의의 문자열을 생성하는 스트림을 구현해 볼 수 있다.
문자열 생성기의 코드를 포함하는 randomStream.js라는 새로운 모듈을 만든다.

```javascript
const stream = require("stream");
const Chance = require("chance");
const chance = new Chance();

class RandomStream extends stream.Readable {
    constructor(options) {
        super(options);
    }

    _read(size) {
        const chunk = chance.string();
        console.log(`Pushing chunk of size: ${chunk.length}`);
        this.push(chunk, "utf8");
        if (chance.bool({ likelihood: 5 })) {
            this.push(null);
        }
    }
}

module.exports = RandomStream;
```

파일의 맨 위에서 의존성들을 로드한다. 숫자에서 문장 전체의 문자열에 이르기까지 모든 종류의 무작위 값을 생성하는 라이브러리인 chance라는 npm 모듈을 로드한다는 점을 제외하면 특별한 것은 없다.

다음 단계는 RandomStream이라는 새로운 클래스를 생성하고 stream.Readable을 부모로 지정하는 것이다.
앞의 코드에서 부모 클래스의 생성자를 호출하여 내부 상태를 초기화하는데 입력된 option 인자를 전달한다.
option 객체를 통해서 전달할 수 있는 변수들은 다음과 같다.

-   버퍼를 문자열로 변환하는데 사용되는 encoding 변수(기본값은 null)
-   객체 모드를 정하는 플래그(objectMode의 기본값은 false)
-   내부 버퍼에 저장되는 데이터의 상한선, 이후 소스로부터 더 이상 데이터를 읽지 않는다.(highWatermark의 기본값은 16K)

좋다. 이제 \_read() 메소드를 설명해보자.

-   이 함수는 chance를 사용하여 임의의 문자열을 생성한다.
-   생성된 문자열을 내부 읽기 버퍼에 푸시한다. String을 푸시(push)하기 때문에 인코딩(utf8)을 지정한다(데이터 덩어리가 단순히 이진 버퍼인 경우에는 필요하지 않다)
-   이 함수는 또 5%의 확률로 내부 버퍼에 EOF 상황, 다시 말해 스트림의 끝을 나타내는 null을 내부 버퍼에 푸시하여 스트림을 무작위적으로 종료시킨다.

\_read() 함수에 입력된 size 인자는 권고 매개변수기 때문에 무시되는 것을 볼 수 있다.
우리는 사용 가능한 모든 데이터를 간단하게 푸시할 수 있었지만, 동일한 호출 내에서 여러 번의 푸시가 있을 경우 push() 함수가 false를 반환하는가를 확인해야 하는데, 이것은 내부 버퍼가 highWatermark 제한에 도달했기 때문에 더 많은 데이터를 추가하는 것을 중지하라는 것을 의미한다.

지금까지는 RandomStream을 위한 것이다. 새로운 모듈을 사용할 준비가 되었다.
여기서 generate Random.js라는 새로운 모듈을 만들어 RandomStream 객체를 인스턴스화하고 그 인스턴스에서 데이터를 획득해보자.

```javascript
const RandomStream = require("./randomStream");
const randomStream = new RandomStream();

randomStream.on("readable", () => {
    let chunk;
    while ((chunk = randomStream.read() !== null)) {
        console.log(`Chunk received: ${chunk.toString()}`);
    }
});
```

이제 새로운 우리만의 스트림을 사용해 볼 수 있다. 평소처럼 generateRandom 모듈을 실행한 후에 화면에 흐르는 임의의 문자열 집합을 관찰하기만 하면 된다.

---

#### Writable 스트림

Writable 스트림은 데이터의 목적지를 나타낸다. Node.js에서는 stream 모듈에서 사용할 수 있는 Writable 추상 클래스르 사용하여 구현한다.
Node.js에서는 stream 모듈에서 사용할 수 있는 Writable 추상 클래스를 사용하여 구현한다.

##### 스트림에 쓰기

일부 데이터를 Writable 스트림으로 밀어내는 작업은 매우 간단하다. 그저 아래와 같은 특징을 가지는 write() 메소드를 사용하면 된다.

```
writable.write(chunk, [encoding], [callback])
```

인코딩 인자는 선택적인 사항이며, chunk가 String일 경우 지정할 수 있다.(기본값은 utf8이며, chunk가 Buffer인 경우 무시된다).
대신 콜백 함수는 chunk가 하위 자원으로 Flush되면 호출되는데, 이 또한 선택적인 사항이다.

더 이상 스트림에 기록할 데이터가 없다는 신호를 보내기 위해서는 end() 메소드를 사용한다.

```
writable.end([chunk], [encoding], [callback])
```

end() 메소드를 사용하여 마지막 데이터를 전달할 수 있는데, 이 경우 콜백 함수는 스트림에 쓴 모든 데이터가 하위 리소스로 플러시 되었을 때 발생하는 finish 이벤트에 리스너를 등록하는 것과 같다.

이제 임의의 일련의 문자열을 출력하는 간단한 HTTP 서버를 만들어 어떻게 동작하는지 보자.

```javascript
const Chance = require('chance');
const chance = new Chance();

require('http').createServer((req, res) => {
    res.writeHead(200, {'Content-Type': 'text/plain'});
    while(chance.bool({likelihood: 95})) {
        res.write(chance.string() + '\n)'
    }
    res.end('\nThe end...\n')
    res.on('finish', () => console.log('All data was sent'));
}).listen(8080, () => console.log('Listening on http://localhost:8080'))
```

여기서 만든 HTTP 서버는 http.ServerResponse의 인스턴스면서 Writable 스트림인 res 객체에 데이터를 쓴다.
아래는 무슨 일이 일어나는지에 대한 설명이다.

1. 먼저 HTTP 응답 헤더를 작성한다. writableHead()는 Writable 인터페이스의 일부가 아니다. 이것은 http.ServerResponse 클래스에 의해 노출된 보조 메소드이다.
2. 5%의 확률로 종료되는 루프를 시작한다(전체 루프의 95%는 chance.bool()에서 true를 반환한다.)
3. 루프 내에서 임의의 문자열을 스트림에 쓴다.
4. 루프가 끝나면 스트림에서 end()를 호출하여 더 이상 쓸 데이터가 없음을 알린다. 또한 스트림을 끝내기 전에 쓸 최종 문자열을 전달한다.
5. 마지막으로 finish 이벤트에 대한 리스너를 등록하는데, 이 이벤트는 모든 데이터가 하위 소켓에 플러시 될 때 발생한다.

이 모듈을 entropyServer.js라고 부르기로 하고, 저장한 후 실행한다. 서버를 테스트하기 위해서 브라우저에 http://localhost:8080을 입력하거나, 다음과 같이 명령창에서 curl을 사용한다.

```
curl localhost:8080
```

이 시점에서 서버는 접속한 HTTP 클라이언트에 임의의 문자열을 보내기 시작한다(일부 브라우저는 데이터를 버퍼링할 수 있어 스트리밍 동작이 분명히 보이지 않을 수도 있다.)

##### 백프레셔(Back-pressure)

실제 파이프 시스템에서 흐르는 액체와 마찬가지로 Node.js 스트림은 스트림이 소비하는 것보다 더 빠르게 데이터를 쓸 경우 병목 현상이 발생할 수 있다.
이를 해결하기 위한 메커니즘은 들어오는 데이터를 버퍼링하는 것이다.
그러나 스트림이 writer에 피드백을 주지 않는다면, 내부 버퍼에 점점 더 많은 데이터가 축적되어 원치 않는 수준의 메모리 사용을 초래하게 될 수 있다.
이런 일이 발생하지 않도록 내부 버퍼의 크기 제한을 나타내는데, write() 메소드가 false를 반환하면 어플리케이션에서는 더 이상의 데이터를 쓰지 말아야 한다.
버퍼가 비워지면 drain 이벤트가 발생하여 다시 쓰기를 시작해도 시작해도 좋다는 것을 알린다.
이 메커니즘을 백프레셔(back-pressure)라고 한다.
