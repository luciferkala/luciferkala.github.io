---
layout: post
title: "4. Node.js Design Pattern Module Pattern"
date: 2020-01-17
excerpt: "Node.js Design Pattern 책 2강 정리 - 2"
tags: [Development, Node.js, ModulePattern, exports, module.export]
comments: true
---

## 모듈 시스템과 그 패턴

모듈은 복잡한 어플리케이션을 구성하기 위한 블록 역할을 하기도 하지만, 명시적으로 익스포트(exports) 표시되지 않은 모든 내부적인 함수와 변수들을 비공개로 유지하여 정보를 숨기는 중요한 메커니즘 이다.

### 노출식 모듈 패턴

JavaScript의 주요 문제점 중 하나가 네임스페이스가 없다는 것이다.
전역 범위에서 실행되는 프로그램은 내부 어플리케이션과 종속된 라이브러리 코드의 데이터들로 인해 충돌이 발생할 수 있다.
이 문제를 해결하기 위한 보편적인 기법을 노출식 모듈 패턴(revealing module pattern)이라고 한다.

```javascript
const module = (() => {
    const privateFoo = () => {...}; //클로저 사용부분
    const privateBar = [];

    const exported = {
        publicFoo: () => {...},
        publicBar: () => {...}
    };

    return exported;
});
console.log(module);
```

이 패턴은 자기 호출 함수를 사용하여 private 범위를 만들고 공개될 부분만 익스포트(export)한다.
앞의 코드에서 출력되는 module 변수는 익스포트된(exported) API만 포함하고 있으며, 나머지 모듈 내부 콘텐츠는 실제로 외부에서 엑세스할 수 없다.
이 패턴의 사상은 Node.js 모듈 시스템의 기반으로 사용된다.

> 자바스크립트 특성상 private한 변수를 만들기 위해서, 클로저를 이용한다. 클로저를 이용하면 외부에서는 내부의 변수에 직접적으로 접근할 수 없어지므로, 접근 제한 private을 구현할 수 있다.

---

### Node.js 모듈 설명

CommonJS는 JavaScript 생태계를 표준화하려는 목표를 가진 그룹으로, 가장 많이 사용되는 제안 중 하나는 CommonJS 모듈이다.
Node.js는 사용자 정의 확장을 추가하여 이 스펙 위에 모듈 시스템을 구축했다.
**각 모듈이 private 범위에서 실행되어 로컬로 정의된 모든 변수가 전역의 네임스페이스와 충돌하지 않는다는 점**에서 노출식 모듈 패턴이 어떻게 작동하는지 유추 할 수 있다.

#### 직접 만드는 모듈 로더

이것이 어떻게 동작하는지를 설명하기 위해 비슷한 시스템을 처음부터 만들어 보자.
다음 코드는 Node.js의 require() 함수의 원래 기능 중 일부를 모방한 함수를 만든 것이다.

먼저 모듈의 내용을 로드하고 이를 private 범위로 감싸 평가하는 함수를 작성해보자.

```javascript
function loadModule(filename, module, require) {
    const wrappedSrc = `(function(module, exports, require) {
        ${fs.readFileSync(filename, "utf8")}
    })(module, module.exports, require);`; //익명함수를 새로 생성하고, 그 익명함수를 즉각적으로 실행 시키는 코드
    eval(wrappedSrc); //문자열을 코드로 인식하여 실행시키는 JavaScript 함수
}

//위와 아래는 같은 코드

function loadModule(filename, module, require) {
    const test = function(module, exports, require) {
        fs.readFileSync(filename, "utf8");
    };
    const wrappedSrc = `test(module, module.exports, require);`;
    eval(wrappedSrc); //문자열을 코드로 인식하여 실행시키는 JavaScript 함수
}
```

모듈의 소스코드는 노출 모듈 패턴과 마찬가지로 기본적으로 함수로 싸여진다.
여기서 차이점은 일련의 변수들(module, exports 그리고 require)을 모듈에 전달한다는 것이다.
이후 보게될 코드에서 래핑 함수의 exports 인자가 module.exports의 내용으로 초기화되는 방식을 자세히 보자.

이제 require() 함수를 구현하여 이러한 변수에 포함된 내용을 살펴보자.

```javascript
const require = moduleName => {
    console.log(`Require invoked for module: ${moduleName}`);
    const id = require.resolve(moduleName); //[1]
    if (require.cache[id]) {
        //[2]
        return require.cache[id].exports;
    }
    //모듈 메타데이터 a
    const module = {
        //[3]
        exports: {},
        id: id
    };
    //캐시 갱신
    require.cache[id] = module; //[4]

    //모듈 로드
    loadMoudle(id, module, require); //[5]

    //익스포트된 변수들을 반환
    return module.exports; //[6]
};
require.cache = {};
require.resolve = moduleName => {
    /* moduleName에서 모듈 ID를 확인 */
};
```

위 함수는 모듈을 로드하는데 사용하는 Node.js의 원래 require() 함수의 동작을 모방하고 있다.
작성한 모듈 시스템은 다음과 같이 설명된다.

1. 모듈 이름을 입력으로 받아 수행하는 첫 번째 일은 우리가 id라고 부르는 모듈의 전체 경로를 알아내는(resolve) 것이다. 이 작업은 이를 해결하기 위해 관련 알고리즘을 구현하고 있는 require.resolve()에 위임됨.
2. 모듈이 이미 로드된 경우 캐시된 모듈을 사용한다. 이 경우 즉시 반환한다.
3. 모듈이 아직 로드되지 않은 경우 최초 로드를 위한 환경을 설정한다. 특히, 빈 객체 리터럴을 통해, 초기화된 exports 속성을 가지고 있는 module 객체를 만든다. exports 속성은 불러올 모듈의 코드에서 모든 public API를 익스포트 하는데 사용된다.
4. module 객체가 캐시된다.
5. 모듈 소스코드는 해당 파일에서 읽어오며, 코드는 앞에서 살펴본 방식으로 평가된다. 방금 생성한 module 객체와 require() 함수의 참조를 모듈에 전달한다. 모듈은 module.exports 객체를 조작하거나 대체하여 public API를 내보낸다.
6. 마지막으로 모듈의 public API를 나타내는 module.exports의 내용이 호출자에게 반환된다.

#### 모듈 정의

우리가 만든 require() 함수가 어떻게 작동하는지 살펴보았으니, 이제 이것을 사용하여 모듈을 정의(define)하는 방법을 알아보자.

```javascript
//다른 종속성 로드
const dependancy = require("./anotherModule");

//private 함수
function log() {
    console.log(`Well done ${dependency.username}`);
}

//익스포트되어 외부에서 사용될 API
module.exports.run = () => {
    log();
};
```

module.exports 변수에 할당되지 않는 한, 모듈 내부의 모든 항목은 private이라는 것이 기억해야 할 핵심 개념이다.
require()를 사용하여 모듈을 로드하면, 이 변수의 내용은 캐싱된 후 반환된다.

#### 전역 정의

모듈에서 선언된 모든 변수와 함수가 로컬 범위로 정의된다 하더라도 여전히 전역 변수를 정의할 수 있는 방법은 있다.
사실, 모듈 시스템은 이 목적을 위해 사용할 수 있는 global이라는 특수 변수를 노출하고 있다. 이 변수에 할당된 모든 항목은 자동으로 전역 범위에 있게 된다.

#### module.exports vs exports

Node.js에 익숙하지 않은 개발자들에게 있어, public API를 공개하기 위해 사용하는 exports와 module.export의 차이점을 이해하는 것은 매우 어려운 일이다.
앞서 작성한 require 함수를 통해 이 차이를 명확하게 이해할 수 있다.
변수 exports는 module.exports의 초기 값에 대한 참조일 뿐이다.
이 값이 본질적으로 모듈이 로드되기 전에 만들어진 간단한 객체 리터럴이라는 것을 보았다.

> exports는 loadModule함수 안에서 wrappedSrc에 할당된 함수의 파라미터를 말하는 것이다. 이것은 우리가 작성한 코드 중 require함수 구현 부에서, module.exports 에 대한 참조이다.

즉, 다음 코드와 같이 exports가 참조하는 객체에만 새로운 속성(properties)을 추가할 수 있다.

```javascript
exports.hello = () => {
    console.log("Hello");
};
```

exports 변수를 재할당 하는 것은 module.exports의 내용을 변경하지 않는다.
따라서 아무런 효과가 없다. 왜냐하면 그것은 exports 변수 자체만을 재할당 하기 때문이다.

> JavaScript에서 객체는 참조 형태로 할당이 된다.
> 즉, loadModule함수를 실행할 때, exports 변수와 module.exports는 같은 객체를 가리키게 된다.
> 그러나 exports는 초기에 모듈을 로드하기 위해 사용하는 매개변수 값일 뿐이다.
> 실제로 우리가 사용하는 public API들은 모두 module.exports에 있다.
> 따라서 exports를 재할당하면, 참조하고 있는 객체가 변경되고 이는 module.exports와 다른 객체를 가리킨다.
> 따라서 exports 변수 재할당은 효과가 없다.

함수, 인스턴스 또는 문자열과 같은 객체 리터럴 이외의 것을 내보내려면 module.exports를 다시 할당해야한다.

#### require 함수는 동기적이다.

우리가 고려해야 할 또 다른 중요한 사항은 우리가 만든 require함수가 **동기적** 이라는 사실이다.
실제로 간단한 직접 스타일을 사용하여 모듈 내용을 반환하므로 콜백이 필요하지 않다.
원래의 Node.js require() 함수도 마찬가지다.
그 결과 **module.exports에 대한 할당도 역시 동기적이어야 한다.**
예를 들어 다음 코드는 올바르지 않다.

```javascript
setTimeout(() => {
    module.exports = function() {...};
}, 100);
```

이 속성은 우리가 모듈을 정의(define)하는 방식에 중요한 영향을 미친다.
왜냐하면 모듈을 정의할 때는 동기적 코드를 주로 사용하기 때문이다.
이것은 실제로 Node.js의 핵심 라이브러리들이 대부분의 Async 라이브러리에 대한 대안으로써 동기 API도 제공하는 가장 중요한 이유들 중의 하나이다.

모듈을 비동기적으로 초기화해야 하는 과정이 필요한 경우에는 모듈이 미래 시점에 비동기적으로 초기화되기 때문에 미처 초기화되지 않은 모듈을 정의하고 익스포트 할 수도 있다.
따라서 이런 접근 방식의 문제점은 require를 사용하여 모듈을 로드한다고 해서 사용할 준비가 된다는 보장이 없다.

> 처음에 모듈 정의를 맨 위에서 동기적으로 실행하면 되는 것이 아닌가?
> 왜 비동기적으로 모듈을 초기화 해야할 경우가 생기며 그것은 언제인가?

#### 해결(resolving) 알고리즘

'의존성 지옥(dependency hell)'이라는 용어는 소프트웨어의 의존성이 서로 공통된 라이브러리들을 의존하지만 호환되지 않는 서로 다른 버전을 필요로 하는 상황을 나타낸다.
Node.js는 **모듈은 로드되는 위치에 따라 다른 버전의 모듈을 로드할 수 있도록 하여** 이 문제를 해결한다.
이 기능의 모든 장점은 npm뿐 아니라 require 함수에서 사용하는 해결(resolving)알고리즘에도 적용된다.

이 알고리즘의 개요를 보자.
resolve() 함수는 모듈 이름을 입력으로 사용하여 모듈 전체의 경로를 반환한다.
**이 경로는 코드를 로드하고 모듈을 고유하게 식별하는데 사용된다.**
해결(resolving) 알고리즘은 크게 다음 세 가지로 나눌 수 있다.

-   파일 모듈: moduleName이 '/'로 시작하면 이미 모듈에 대한 _절대 경로_ 라고 간주되어 그대로 반환된다. ./으로 시작하면 moduleName은 _상대 경로_ 로 간주되며, 이는 요청한 모듈로부터 시작하여 계산된다.
-   코어 모듈 : moduleName이 '/' 또는 './'로 시작하지 않으면 알고리즘은 먼저 코어 Node.js 모듈 내에서 검색을 시도한다.
-   패키지 모듈 : moduleName과 일치하는 코어 모듈이 없는 경우, 요청 모듈의 경로에서 시작하여 디렉터리 구조를 탐색하여 올라가면서 **node_modules** 디렉터리를 찾고 그 안에서 일치하는 모듈을 찾기를 계속한다.
    알고리즘은 파일 시스템의 루트에 도달할 때까지 디렉터리 트리를 올라가면서 다음 **node_modules** 디렉터리를 탐색하여 계속 일치하는 모듈을 찾는다.

파일 및 패키지 모듈의 경우 개별 파일과 디렉터리가 모두 moduleName과 일치할 수 있다.
알고리즘은 다음과 일치하는지를 본다.

-   &lt;MODULENAME&gt;.js
-   &lt;MOUDLENAME&gt; /index.js
-   &lt;moduleName&gt; /package.json의 main 속성에 지정된 디렉터리/파일

node_modules 디렉터리는 실제로 npm이 각 패키지의 의존성을 설치하는 곳이다.
즉, 방금 설명한 알고리즘을 기반으로 각 패키지는 자체적으로 개별적인 의존성을 가질 수 있다.
해석 알고리즘의 규칙에 따라 require(module)을 사용하면 모듈을 필요로 하는 모듈에 따라 다른 파일이 로드된다.

해결 알고리즘은 Node.js 의존성 관리의 견고성을 뒷받침하는 핵심적인 부분이며, 충돌 혹은 버전 호환성 문제 없이 어플리케이션에서 수백 또는 수천 개의 패키지를 가질 수 있게 한다.

해결 알고리즘은 require()를 호출할 때 분명하게 적용된다.
그러나 필요하다면, require.reslove()를 호출하여 모듈에서 직접 사용될 수도 있다.

#### 모듈 캐시

require()의 후속 호출은 단순히 캐시된 버전을 반환하기 때문에 각 모듈은 처음 로드될 때만 로드되고 평가된다.
캐싱은 성능을 위해 매우 중요하지만, 다음과 같은 기능적인 영향도 있다.

-   모듈 의존성 내에서 순환을 가질 수 있다.
-   일정한 패키지 내에서 동일한 모듈이 필요할 때는 어느 정도 동일한 인스턴스가 항상 반환된다는 것을 보장한다.

모듈 캐시는 require.cache 변수를 통해 외부에 노출되므로 필요한 경우 모듈 캐시에 직접 액세스할 수 있다.
일반적인 사용 사례는 require.cache 변수에서 관련 키를 삭제하여 캐시된 모듈을 무효화하는 것이다.
이것은 실습을 위한 테스트에서는 매우 유용하지만 일반적인 상황에 적용하는 것은 매우 위험하다.

#### 순환 의존성

많은 사람들이 순환 의존성을 본질적인 설계 문제라고 생각하지만, 프로젝트에서 실제로 발생할 수 있기 때문에 최소한 Node.js에서 어떻게 작동하는지 아는 것이 좋을 것이다.
우리가 직접 만든 require() 함수를 다시 보면 이것이 어떻게 작동하는지, 무엇을 조심해야 하는지 바로 알 수 있을 것이다.

다음과 같이 정의된 두 개의 모듈이 있다고 보자.

```javascript
//Module a.js :
const b = require('./b);
module.exports = {
    bWasLoaded: b.loaded,
    loaded: true
};
```

```javascript
//Module b.js :
exports.loaded = false;
const a = require('./a);
module.exports = {
    aWasLoaded: a.loaded,
    loaded:
};
```

이제 다음과 같이 다른 모듈인 main.js에서 모듈을 로드해보자.

```javascript
//main.js :
const a = require("./a");
const b = require("./b");
console.log(a);
console.log(b);
```

```javascript
    { bWasLoaded: true, loaded: true }
    { aWasLoaded: false, loaded: false }
```

> 이 코드를 실행 시켰을 때, 다음과 같은 결과가 나오기 보다, 오류가 나타났다.
> 오류가 난 이유를 제대로 알아보고 추후에 추가하겠다.

이 결과로 순환 종속성에 대한 문제를 알 수 있다.
두 모듈 모두 각자 main에서 require로 불려지면 완전하게 초기화되지만, b.js에서 a.js모듈을 로드하면 모듈의 로드가 완료되지 않는다.
a.js가 b.js를 required하는 순간에 다다르게 되는 것이다.
main.js에서 require로 불려지는 두 모듈의 순서를 바꾸어 보면, 바뀌는 출력을 통해 이러한 동작을 확인할 수 있다.

한 번 시도해 보면, 이번에는 a.js로 인해 b.js가 불완전하게 셋팅되는 것을 알 수 있다.
이 예로 우리는 어떤 모듈이 먼저 로딩되는지를 놓치게 되면 매우 불분명한 문제가 될 수 있다는 것을 알았다.
프로젝트가 어느 정도 규모가 된다면 꽤 쉽게 발생할 수 있는 문제다.

### 모듈 정의 패턴

모듈 시스템은 의존성을 로드하는 메커니즘이 되는 것 외에 API를 정의하기 위한 도구이기도 한다.
API 디자인과 관련된 다른 문제의 경우 고려해야 할 주요 요소는 private 함수와 public 함수 간의 균형이다.
이것의 목표는 확장성과 코드 재사용 같은 소프트웨어 품질과의 균형을 유지하면서 정보 은닉 및 API 유용성을 극대화하는 것이다.

이 섹션에서는 Node.js에서 모듈을 정의할 때 가장 많이 사용되는 몇 가지 패턴을 분석한다.
각각 자신만의 정보 은닉, 확장성 및 코드 재사용에 대한 균형을 이루고 있다.

#### exports 지정하기(named exports)

public API를 공개하는 가장 기본적인 방법은 export로 명기하는 것이다. 이것은 exports에서 참조하는 객체(또는 module.export)의 속성에 공개할 모든 값을 할당하는 것이다.
이렇게 하면 외부에 공개된 객체(모듈)가 일련의 관련 기능들에 대한 컨테이너 또는 네임 스페이스가 된다.

다음 코드는 이 패턴을 구현하는 모듈을 보여준다.

```javascript
//logger.js 파일
exports.info = message => {
    console.log("info: " + message);
};

exports.verbose = message => {
    console.log("verbose: " + message);
};
```

그렇게 내보내진 함수들은 다음에 보는 바와 같이 로드된 모듈의 속성처럼 사용이 가능하다.

```javascript
//main.js 파일
const logger = require("./logger");
logger.info("This is an informational message");
logger.verbose("This is a verbose message");
```
