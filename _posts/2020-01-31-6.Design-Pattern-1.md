---
layout: post
title: "16. Node.js Design Pattern - Design Pattern - Factory Pattern"
date: 2020-01-31
excerpt: "Node.js Design Pattern 책 6강 정리 - 1"
tags:
    [
        Development,
        Node.js,
        JavaScript,
        ECMA2015,
        Design Pattern,
        Factory,
        Factory Pattern,
    ]
comments: true
---

디자인 패턴은 **되풀이되는 문제에 대한 재사용 가능한 솔루션이다.**
이 용어는 정의가 매우 광범위하며 어플리케이션의 여러 도메인으로 확장될 수 있다.
그러나 이 용어는 90년대에 대중적으로 객체지향 패턴 집합으로 **전설적인 4인방(GoF)** Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides이 쓴 책인 "디자인 패턴: 재사용 가능한 객체지향 소프트웨어, 피어슨에듀케이션"과 관련되어 있다.
우리는 종종 이렇한 특정 패턴의 집합을 "전통적인 디자인 패턴" 또는 "GoF 디자인 패턴"이라고 부른다.

JavaScript에서 객체지향 디자인 패턴들을 적용하는 것은 고전적인 객체지향 언어에서처럼 선형적이고 정석적이지 않다.
알다시피, JavaScript은 멀티패러다임, 객체지향, 프로토타입 기반이며 동적 자료형을 가지고 있다.
함수를 일급 객체로 취급하고 함수 중심 프로그래밍 스타일을 허용한다.
이러한 특성은 JavaScript를 매우 다재 다능한 언어로 만들어 개발자에게 엄청난 힘을 부여하지만 동시에 프로그래밍 스타일, 규칙, 기술 그리고 궁극적으로는 생태계의 패턴을 분열시키는 원인이 된다.
JavaScript를 사용하여 동일한 결과를 얻는데는 여러 가지 방식이 있다.
모든 사람들은 어떤 것이 문제에 대한 최선의 접근법인지에 대한 자신의 견해를 가지고 있다.
이를 명확하게 증명하듯이 JavaScript 생태계에는 풍부한 프레임워크와 독창적인 라이브러리가 많다.
Node.js가 JavaScript에 새로운 가능성을 부여하고 새로운 시나리오를 만든 지금, 아마 다른 어떤 언어도 그렇게 많은 것은 보지 못했을 것이다.

이러한 맥락에서 전통적인 디자인 패턴은 JavaScript의 특성에도 영향을 받았다.
JavaScript에는 그들의 전통적이고 강력한 객체지향적인 구현체를 구현하는 방법이 수도 없이 많이 있기 때문에 더 이상 패턴이라 부를 수 없을 수도 있다.
어떤 경우는 JavaScript에 실제 클래스나 추상 인터페이스가 없기 때문에 불가능할 수도 있다.
그래도 각 패턴의 기반에 있는 독창적인 아이디어, 해결 해야 할 문제 그리고 해결책의 핵심에 있는 개념은 변하지 않는다.

이 장에서는 가장 중요한 GoF 디자인 패턴 중 일부가 node.js와 그 철학에 어떻게 적용되는지를 살펴봄으로써 다른 관점에서 이들의 중요성을 재발견할 것이다.
이러한 전통적인 패턴들 사이에, JavaScript 생태계 내에서 생성된 "덜 전통적인" 디자인 패턴들도 살펴 볼 것이다.

이 장에서 살펴볼 디자인 패턴은 다음과 같다.

-   팩토리(Factory)
-   공개 생성자(Revealing constructor)
-   프록시(Proxy)
-   데코레이터(Decorator)
-   어댑터(Adapter)
-   전략(Strategy)
-   상태(State)
-   템플릿(Template)
-   미들웨어(Middleware)
-   명령(Command)

> 이 장에서는 JavaScript에서 상속이 동작하는 방식에 대한 이해가 있다고 가정하겠다.
> 이 장의 전반에 걸쳐 제너릭(generic)을 사용하며 많은 패턴들이 클래스뿐만 아니라, 객체와 함수에 기반을 둔 구현을 가지기 때문에 패턴을 설명하는데 표준 UML을 대신하여 좀 더 직관적인 그림을 사용한다.

---

## 팩토리(Factory)

우리는 Node.js에서 아마도 가장 간단하고 공통적인 디자인 패턴인 팩토리(factory) 패턴에서부터 긴 여정을 시작할 것이다.

### 객체를 생성하기 위한 제너릭 인터페이스

우리는 JavaScript에서 단순성, 유연성, 그리고 작은 공개 API를 위해 함수 위주의 패러다임이 순수한 객체지향 설계보다 더 선호된다는 사실을 이미 강조해 왔다.
이는 객체의 새 인스턴스를 작성할 때 특히 그렇다.
실제로, new 연산자 또는 Object.create()를 사용하여 프로토타입에서 직접 새 객체를 만드는 대신 팩ㅌ리를 호출하면 여러 면에서 훨씬 편리하고 유연하다.

무엇보다 먼저 팩토리는 객체 생성을 구현과 분리할 수 있게 해준다.
근본적으로 팩토리는 새로운 인스턴스의 생성을 감싸서 우리가 하는 방식에 더 많은 유연성과 제어력을 제공한다.
팩토리 내에서 클로저를 활용하고 프로토타입과 new 연산자, Object.create()를 사용하여 새로운 인스턴스를 만들거나 또는 특정 조건에 따라 다른 인스턴스를 반환할 수도 있다.
팩토리의 소비자는 인스턴스 생성이 수행되는 방법에 대해서는 전적으로 알 필요가 없다.
new 연산자를 사용하면 객체 하나를 생성하는데 한 가지 특정한 방법으로만 코드를 바인드할 수 있으나 JavaScript에서는 더 유연하고 거의 제약이 없을 수 있다.
간단한 예로써 Image 객체를 만드는 간단한 팩토리를 생각해보자.

```javascript
function createImage(name) {
    return new Image(name);
}
const image = createImage("photo.jpeg");
```

createImage() factory는 전혀 필요없는 것처럼 보인다.
다음 코드와 같이 직접 new 연산자를 사용하여 Image 클래스를 인스턴스화하는 것이 어떨까?

```javascript
const image = new Image(name);
```

이미 언급햇듯이 new를 사용하면 하나의 특정한 유형의 객체 만을 코드에 바인딩할 수 있다.
위의 경우 Image 유형의 객체에 바인딩된다.
팩토리는 대신 더 많은 유연성을 제공한다.
Image 클래스를 각각의 이미지 형식에 맞는 더 작은 객체들로 나누어 리팩토링 한다고 생각해보자.
새로운 Image를 생성하는 유일한 방법으로 팩토리를 사용한 경우, 기존 코드의 변경을 최소화하여 다음과 같이 간단하게 작성할 수 있다.

```javascript
function createImage(name) {
    if (name.match(/\.jpeg$/)) {
        return new JpegImage(name);
    } else if (name.match(/\.gif$/)) {
        return new GifImage(name);
    } else if (name.match(/\.png$/)) {
        return new PngImage(name);
    } else {
        throw new Exception("Unsupported format");
    }
}
```

factory는 또한 생성된 객체의 생성자를 노출시키지 않고 객체를 확장하거나 수정하지 못하도록 한다.(작은 표면적의 원칙 - principle of small surface area을 기억하는가?)
Node.js에서는 각 생성자를 비공개로 유지하면서 팩토리만 내보내는 방법으로 이 작업을 수행할 수 있다.
