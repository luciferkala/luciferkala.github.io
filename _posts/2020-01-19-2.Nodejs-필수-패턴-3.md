---
layout: post
title: "5. Node.js Design Pattern Observer Pattern"
date: 2020-01-17
excerpt: "Node.js Design Pattern 책 2강 정리 - 3"
tags: [Development, Node.js, ObserverPattern, EventEmitter]
comments: true
---

Node.js에서 사용되는 또 다른 중요하고 기본적인 패턴은 관찰자 패턴(Observer Pattern)이다.
Reactor, Callback, Module과 함께 Observer Pattern은 플랫폼의 핵심 중 하나이다.

관찰자 패턴은 Node.js의 반응적인 특성을 모델링하고 콜백을 완벽하게 보완하는 해결책이다.
정의는 다음과 같다.

> **_관찰자 패턴_**은 상태 변화가 일어날 때 관찰자(또는 Listener)에게 알릴 수 있는 객체
> (Subject라고 불린다)를 정의하는 것이다.

콜백 패턴과의 가장 큰 차이점은 Subject가 실제로 여러 관찰자(Observer)들에게 알릴 수 있다는 점이다.
전통적이 연속 전달 스타일 콜백은 일반적으로 그 결과를 하나의 Listener 인 콜백에만 전파한다.

---

### EventEmitter 클래스

전통적인 객체지향 프로그래밍에서 관찰자 패턴에는 인터페이스와 구현된 클래스들 그리고 계층 구조가 필요하다.
그러나 Node.js에서는 EventEmitter 클래스를 사용하면 된다.
EventEmitter 클래스를 사용하여 특정 유형의 이벤트가 발생되면 호출될 하나 이상의 함수를 Listener로 등록할 수 있다.

![ObserverPattern](../assets/img/NodejsDesignPattern/post5/observerPattern.jpg)
링크 : [https://subscription.packtpub.com/book/web_development/9781785885587/2/ch02lvl1sec14/the-observer-pattern](https://subscription.packtpub.com/book/web_development/9781785885587/2/ch02lvl1sec14/the-observer-pattern)

EventEmitter는 **프로토타입(prototype)이며** 코어 모듈로부터 익스포트 된다.
다음 코드는 우리가 EventEmitter에 대한 참졸를 얻을 수 있는 방법을 보여준다.

```javascript
const EventEmitter = require("events").EventEmitter;
const eeInstance = new EventEmitter();
```

EventEmitter의 필수 메소드는 다음과 같다.

-   on(event, listener) : 이 메소드를 사용하면 주어진 이벤트 유형(문자열)에 대해 새로운 listener를 등록할 수 있다.
-   once(event, listener) : 이 메소드는 첫 이벤트가 전달된 후 제거되는 새로운 listener를 등록한다.
-   emit(event, [arg1], [...]) : 이 메소드는 새 이벤트를 생성하고 listener에게 전달할 추가적인 인자들을 지원한다.
-   removeListener(event, listener) : 이 메소드는 지정된 이벤트 유형에 대한 listener를 제거한다.

앞의 모든 메소드들은 연결(chaining)을 가능하게 하기 위해 EventEmitter 인스턴스를 반환한다.
listener 함수는 시그니처 함수([arg1], [...])를 가지고 있기 떄문에 이벤트가 발생된 순간에 전달되는 인수들을 쉽게 받아 들일 수 있다. listener 내부에서는 이벤트를 생성하는 EventEmitter의 인스턴스를 참조한다.

앞서 이미 listener와 전통적인 Node.js 콜백 간에 큰 차이가 있음을 보았다.
특히, 첫 번째 인자가 꼭 에러(error)일 필요는 없으며, emit()이 호출될 때 전달된 어떤 값이든 가능하다.

---

### EventEmitter 생성 및 사용

실제로 EventEmitter를 어떻게 사용할 수 있는지 보도록 하겠다.
가장 간단한 방법은 새로운 인스턴스를 만들어 바로 사용하는 것이다.
다음 코드는 EventEmitter를 사용하여 파일 목록에서 특정 패턴이 발견되면 실시간으로 구독자들에게 알리는 함수를 보여준다.

```javascript
const EventEmitter = require("events").EventEmitter;
const fs = require("fs");

function findPattern(files, regex) {
    const emitter = new EventEmitter();
    files.forEach(file => {
        fs.readFile(file, "utf8", (err, content) => {
            if (err) return emitter.emit("error", err);
        });

        emitter.emit("fileread", file);
        let match;
        if ((match = content.match(regex)))
            match.forEach(elem => emitter.emit("found", file, elem));
    });
    return emitter;
}

위의 함수로 만든 EventEmitter는 세 가지 이벤트를 생성한다.
- fileread: 이 이벤트는 파일을 읽을 때 발생한다.
- found: 이 이벤트는 일치하는 항목이 발견되었을 때 발생한다.
- error: 이 이벤트는 파일을 읽는 동안 오류가 발생했을 때 발생한다.
```

filePattern() 함수를 어떻게 사용할 수 있는지 알아보자.

```javascript
findPattern(["fileA.txt", 'fileB.json'],
/hello \w+g)
.on('fileread', file => console.log(file + ' was read')
)
.on('found', (file, match) => console.log('Matched "' + match + '" in file ' + file))
.on('error', err => console.log('Error emitted: ' + err.message));
```

앞의 예에서 findPattern() 함수에서 만들어진 EventEmitter에 의해 생성된 세 가지 유형의 이벤트 각각에 대해 listener를 등록했다.

---

#### 오류 전파

EventEmitter는 이벤트가 비동기적으로 발생할 경우, 이벤트 루프에서 손실될 수 있기 때문에 콜백에서와 같이 예외가 발생해도 예외를 바로 throw할 수 없습니다. 대신, 규약에 의해 error라는 특수한 이벤트를 발생시키고, Error 객체를 인자로 전달한다.
이것이 정확히 우리가 앞에서 정의한 findPattern() 함수에서 하고 있는 것이다.

Node.js는 특별한 방식으로 에러 이벤트를 처리하고 예외를 자동으로 throw하며, 이에 연결된 리스너가 없는 경우 프로그램을 종료하므로 항상 에러 이벤트에 대한 리스너를 등록하는 것이 좋다.

---

#### 관찰 가능한 객체 만들기

때로는 EventEmitter 클래스를 가지고 직접 새로운 관찰 대상 객체를 만드는 것만으로는 충분하지 않을 수 있다.
이런 방식으로 단순한 새로운 이벤트를 만드는 것 이상의 기능을 제공하는 것은 비현실적이다.
실제로 일반적인 객체를 관찰 가능하게 만드는 것이 일반적이다.
이것은 EventEmitter 클래스를 확장함으로써 가능하다.

이 패턴을 설명하기 위해 다음과 같이 객체에서 findPattern() 함수의 기능을 구현해 보겠다.

```javascript
const EventEmitter = require("events").EventEmitter;
const fs = require("fs");

class FindPattern extends EventEmitter {
    constructor(regex) {
        super();
        this.regex = regex;
        this.files = [];
    }

    addFile(file) {
        this.files.push(file);
        return this;
    }

    find() {
        this.files.forEach(file => {
            fs.readFile(file, "utf8", (err, content) => {
                if (err) {
                    return this.emit("error", err);
                }

                this.emit("fileread", file);

                let match = null;
                if ((match = content.match(this.regex))) {
                    match.forEach(elem => this.emit("found", file, elem));
                }
            });
        });
        return this;
    }
}
```

우리가 정의한 FindPattern 프로토타입은 코어 모듈 util에서 제공하는 inherits() 함수를 사용하여 EventEmitter를 확장한다.
이 같은 방법으로 완벽하게 관찰 가능한 클래스가 된다.
다음은 그 사용의 예다.

```javascript
const findPatternObject = new FindPattern(/hello \w+/);
findPatternObject
    .addFile('fileA.txt')
    .addFile('fileB.json')
    .find()
    .on('found', (file,match) => console.log(`Matched "${match}
    " in file ${file}`))
    .on('error', err => console.log(`Error emitted ${err.message}`)
```

FindPattern 객체가 전체 메소드를 그대로 보유한 상태에서 EventEmitter의 기능을 상속함으로써 어떻게 관찰 가능하게 되는지를 확인할 수 있다.

이것은 Node.js에서 꽤 일반적인 패턴이다. 예를 들어 핵심 HTTP 모듈인 Server 객체는
listen(), close(), setTimeout()과 같은 메소드를 정의하며 내부적으로 EventEmitter 함수에서 상속받는다.
따라서 새로운 요청이 수신될 때 request 이벤트, 새로운 연결이 설정되면 connection 이벤트 그리고 서버가 닫히면 closed 이벤트가 생성된다.

EventEmitter를 확장하는 객체의 다른 주목할만한 예는 Node.js 스트림이다.
