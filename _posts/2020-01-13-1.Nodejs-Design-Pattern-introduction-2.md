---
layout: post
title: "2. Node.js Design Pattern Reactor Pattern"
date: 2020-01-13
excerpt: "Node.js Design Pattern 책 1강 정리 - 2"
tags: [Node.js, ReactorPattern, ECMA2015]
comments: true
---

## Reactor 패턴

Node.js의 비동기 핵심 패턴은 Reactor 패턴으로 동작한다.
단일 스레드 아키텍처 와 논 블로킹 I/O와 같은 패턴의 기본개념을 정리하고, 이 개념을 바탕으로 Node.js의 기반을 형성하는 방법을 본다.

## I/O

I/O는 컴퓨터의 기본적인 동작 중에서 가장 느리다.

### 블로킹 I/O

전통적인 블로킹 I/O 프로그래밍에서는 I/O 요청에 해당하는 함수 호출은 작업이 완료될 때까지 스레드의 실행이 차단된다.
```c
// 데이터를 사용할 수 있을 때까지 스레드가 블록됨.
data = socket.read();
// 데이터 사용 가능
print(data);
```

블로킹 I/O를 사용하여 구현된 웹 서버는 동일한 스레드에서 여러 연결을 처리할 수 없다.
각 소켓에서의 모든 I/O 작업이 다른 연결 처리를 차단할 것이기 때문이다.
따라서, 웹 서버에서 동시성을 처리하기 위한 전통적인 접근 방식은 다음과 같다.

- 각각의 동시 연결에 대해 새로운 스레드 또는 프로세스 시작
- 풀에서 가져온 스레드 재사용

이렇게 하면 스레드가 I/O 작업으로 차단되어도 분리된 스레드에서 처리되므로 다른 요청의 가용성에는 영향을 미치지 않는다.

그러나 스레드 또한 I/O 작업을 수행 할 시 많은 유휴 상태에 들어가게 된다.
그리고 스레드를 사용하는 것이 리소스 측면에서 비용을 많이 사용하므로, 장시간 실행되는 스레드는 효율성 측면에서 좋은 편은 아니다.

### 논 블로킹 I/O

대부분 최신 운영체제는 블로킹 I/O 외에도 논 블로킹 I/O를 지원한다. 
이 메커니즘에서 시스템 호출은 데이터가 읽히거나 쓰여질 때까지 기다리지 않고 항상 즉시 반환된다.
호출하는 순간에 결과를 사용할 수 없는 경우, 이 함수는 단순히 미리 정의된 상수를 반환하여 그 순간에 반환할 수 있는 데이터가 없음을 나타낸다.

논 블로킹 I/O에 엑세스하는 가장 기본적인 패턴은 실제 데이터가 반환될 때까지 루프 내에서 리소스를 적극적으로 __폴링(poll)__ 하는 것이다.
이것을 Busy-watinㅇ이라고 한다.

> __폴링(Poll)이란?__
>
> "폴링(polling)이란 하나의 장치(또는 프로그램)이 충돌 회피 또는 동기화 처리 등을 목적으로 다른 장치(또는 프로그램)의 상태를 주기적으로 검사하여 일정한 조건을 만족할 때 송수신 등의 자료처리를 하는 방식을 말한다."
>
> 즉, 일정시간 간격으로 응답을 주고 받을 때 까지 검사하는 것이다.

아래의 의사 코드는 논 블로킹 I/O 및 폴링 루프를 사용하여 여러 리소스에서 읽는 방법을 보여주는 예시이다.

```javascript
resources = [socketA, socketB, pipeA];
while(!resources.isEmpty()) {
    for(let i in resources) {
        resource = resources[i];
        //읽기를 시도합니다.
        let data = resource.read();
        if(data === NO_DATA_AVAILABLE)
            //만약 당장 읽을 데이터가 없다면,
            continue;
        if(data === RESOURCE_CLOSED
            //데이터 리소스가 닫혔기 때문에, 리소스 목록에서 제거한다.
            resources.remove(i);
        else
            //데이터가 도착하여 이를 처리한다.
            consumeData(data);
    }
}
```

폴링을 사용하여 동일한 스레드에서 서로 다른 리소스를 처리할 수 있지만, 효율적이지는 않다.
실제로 앞의 예제에서 루프는 대부분의 경우 사용할 수 없는 리소스를 반복하는데만 CPU를 사용한다.
폴링 알고리즘은 대부분 엄청난 양의 CPU 시간 낭비를 초래한다.

### 이벤트 디멀티플렉싱
효율적인 논 블로킹 리소스 처리를 위한 기본 메커니즘은 __동기 이벤트 디멀티플렉서__ 또는 __이벤트 통지 인터페이스__ 라고 한다.
이 구성 요소는 감시된 일련의 리소스들로부터 들어오는 I/O 이벤트를 수집하여 큐에 넣고 처리할 수 있는 새 이벤트가 있을 때까지 차단한다.

> #### 이벤트 디멀티플렉서(Event Demultiplexer)
> 
> 사실 이벤트 디멀티플렉서라는 이름 자체에서 이것의 사용 목적을 알 수 있는데,
> 그러러면 _멀티플렉스(multiplex)_ 라는 단어를 알아야한다.
> 데이터 통신에서 사용하는 멀티플렉스는 여러개의 신호를 하나의 신호에 합쳐서 보내는 기법을 이야기 한다.
> 따라서 이벤트 디멀티플렉스를 여기서 반대로 생각해보자. 
> 이벤트들을 담고 있는 하나의 통에 담긴 이벤트들을 각각의 이벤트들로 나누고 이를 Node.js의 싱글 스레드에 집어넣어주는 역할을 하는 개체가 이벤트 디멀티플렉서라고 자연스럽게 생각할 수 있다.

다음은 두 개의 서로 다른 자원에서 읽기 위해 _일반 동기 이벤트(generic synchronous event)_ 디멀티플렉서를 사용하는 알고리즘의 의사코드이다.

```javascript
socketA, pipeB;
watchedList.add(socketA, FOR_READ); //[1]
watchedList.add(pipeB, FOR_READ);
while(events = demultiplexer.watch(watchedList)) { //[2]
    //이벤트 루프
    foreach(event in events) { //[3]
        //여기서 read는 블록되지 않으며 비어 있을지언정, 항상 데이터를 반환한다.
        data = event.resource.read();
        if(data === RESOURCE_CLOSED)
            //리소스가 닫혔기 때문에, 리소스 목록에서 제거한다.
            demultiplexer.unwatch(event.resource);
        else
            //실제 데이터가 도착하여 이를 처리한다.
            consumeData(data);
    }
}
```

위 의사 코드의 주요 과정은 다음과 같다.
1. 리소스를 데이터 구조(List)에 추가한다. 예제에서는 각 인스턴스를 특정 작업(여기서는 read)과 연결한다.
2. 이벤트 통지자에 감시할 리소스 그룹을 설정한다. 이 호출은 __동기식__ 이며, 감시 대상 자원 중 하나라도 읽을 준비가 될 때까지 차단된다. 이 경우, 이벤트 디멀티플렉서는 호출로부터 복귀하여 새로운 일련의 이벤트들을 처리할 수 있게 된다. (호출이 동기식이기 때문에, 의사코드에서 while문의 조건문이 실행완료 될 때 까지, 코드 실행이 멈춰 있다고 생각하면 된다.)
3. 이벤트 디멀티플렉서에 의해 반환된 각 이벤트가 처리된다. 이 시점에서 각 이벤트와 관련된 리소스는 읽기 작업을 위한 준비가 되어 있으며, 차단되지 않는 상황이라는 것이 보증 된다. 모든 이벤트가 처리되고 나면, 이 흐름은 다시 디멀티플렉서에서 처리 가능한 이벤트가 발생할 때까지