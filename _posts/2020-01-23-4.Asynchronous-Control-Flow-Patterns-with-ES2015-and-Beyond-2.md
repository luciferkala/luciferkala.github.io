---
layout: post
title: "10. Node.js Design Pattern Asynchronous Control Flow Patterns with ES2015 and Beyond - Generator"
date: 2020-01-22
excerpt: "Node.js Design Pattern 책 4강 정리 - 2"
tags: [Development, Node.js, Async, Generator, yield, JavaScript, ECMA2015]
comments: true
---

## 제너레이터(Generator)

이번에는 세미 코루틴(semi-coroutines)이라고도 하는 **제너레이터(Generator)**에 대해 이야기 해보자.
제너레이터는 **다른 진입점이 있을 수 있는 서브 루틴들을 일반화한 것**이다.
보통의 함수에서는 실제 함수 자체의 호출에 해당하는 하나의 진입점 만을 가질 수 있다.
제너레이터는 함수와 비슷하지만(yield 문을 사용하여) **일시적으로 실행의 흐름을 중지시켰다가, 이후 다시 시작시킬 수 있다.**
제너레이터는 반복자(Iterator)를 구현할 때 특히 유용한데, 반복자(Iterator)라는 것은 순차 및 제한된 병렬 실행과 같이 중요한 비동기 제어 흐름 패턴을 구현해 볼 때 그 사용법을 설명했었기 때문에 그리 낯설지는 않을 것이다.

### 제너레이터의 기본

비동기식 제어 흐름에 바로 제너레이터를 사용해 보기 전에 기본적인 개념을 먼저 익히는 것이 좋을 듯 하다.
문법부터 시작해 보겠다.
제너레이터 함수는 function 키워드 다음에 \*(별표)연산자를 추가하여 선언할 수 있다.

```javascript
function* makeGenerator() {
    // 함수 본문
}
```

makeGenerator() 함수 내에서는 yield 키워드를 사용하여 실행을 일시 중지하고 전달된 값을 호출자에게 반환할 수 있다.

```javascript
function* makeGenerator() {
    yield "Hello World";
    console.log("Re-entered");
}
```

앞의 코드에서 제너레이터는 Hello World라는 문자열을 반환하는 곳에서 yield(값을 반환하거나 주입 받음)한다.
제너레이터가 다시 시작되면 console.log('Re-entered')에서 실행이 계속된다.

**_makeGenerator() 함수는 본질적으로 호출될 때 새로운 제너레이터 객체를 반환하는 팩토리(factory)이다._**

```javascript
const gen = makeGenerator();
```

제너레이터 객체의 가장 중요한 메소드는 next() 이다. next()는 제너레이터의 실행을 시작/재시작하는데 사용되며, 다음과 같은 형식의 객체를 반환한다.

```javascript
{
    value: <yield시 반환값>,
    done: <제너레이터가 끝났는지 여부>
}
```

이 객체에는 제너레이터에서 생성한 값(value)과 제너레이터의 실행이 완료되었는지를 나타내는 플래그(done)가 포함된다.

#### 간단한 예

제너레이터를 시연해 보기 위해 fruitGenerator.js라는 새로운 모듈을 생성한다.

```javascript
function* fruitGenerator() {
    yield "apple";
    yield "orange";
    return "watermelon";
}

const newFruitGenerator = fruitGenerator();
console.log(newFruitGenerator.next()); //[1]
console.log(newFruitGenerator.next()); //[2]
console.log(newFruitGenerator.next()); //[3]
```

위 코드는 다음과 같은 결과를 출력한다.

```javascript
{value: 'apple', done: false}
{value: 'orange', done: false}
{value: 'watermelon', done: true}
```

다음은 이 실행 동작에 대한 간단한 설명이다.

-   newFruitGenerator.next() 가 처음으로 호출되었을 때, 제너레이터는 첫 번째 yield 명령에 도달할 때까지 실행을 계속한다. 이 명령은 제너레이터를 일시 중지시키고 값 apple을 호출자에게 반환한다.
-   newFruitGenerator.next() 가 두 번째 호출하면 제너레이터는 두 번째 yield 명령에서 실행을 시작하여 다시 실행을 일시 중지하고 orange 값을 호출자에게 반환한다.
-   newFruitGenerator.next()의 마지막 호출은 제너레이터의 마지막 명령으로 제너레이터를 끝내는 return 문에서 재시작하여 value를 watermelon으로 설정하고 done을 true로 설정하여 반환한다.

#### 반복자(Iterator)로서의 제너레이터(Generator)

제너레이터가 반복자를 구현하는데 왜 유용한지 더 잘 이해하기 위해, 제너레이터를 만들어 보겠다.
IteratorGenerator.js라고 하는 새로운 모듈에 다음과 같은 코드를 작성해보자.

```javascript
function* iteratorGenerator(arr) {
    for (let i = 0; i < arr.length; i++) {
        yield arr[i];
    }
}

const iterator = iteratorGenerator(["apple", "orange", "watermelon"]);
let currentItem = iterator.next();
while (!currentItem.done) {
    console.log(currentItem.value);
    currentItem = iterator.next();
}
```

이 코드는 다음과 같은 배열의 항목들을 출력한다.

```
apple
orange
watermelon
```

이 예제에서 iterator.next()를 호출할 때마다 일시정지 되었던 제너레이터의 for 루프를 다시 시작한다.
이것은 배열의 다음 항목을 반환(yielding)하는 다음 사이클을 실행한다.
이것은 호출될 때마다 제너레이터의 내부 상태가 유지되는 모습을 보여준다.
루프가 다시 시작될 때 모든 변수들의 상태는 실행이 일시 중지되었을 때와 완전히 동일하다.

#### 값을 제너레이터로 전달하기

제너레이터의 기본 기능에 대해 알아보는 과정의 마지막으로 이제 값을 제너레이터로 전달하는 방법을 알아보겠다.
실제 이것은 매우 간단하다. 우리가 할 일은 next() 메소드에 인자를 전달하는 것이고 이 값이 제너레이터 내부의 yield 문의 반환값으로 제공된다.
